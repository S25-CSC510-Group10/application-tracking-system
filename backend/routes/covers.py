"""
This module contains the routes for uploading and downloading cover letters.
"""

from flask import Blueprint, jsonify, request, send_file, current_app
from models import Users
from utils import get_userid_from_header
from db import db
from config import config
from markdown import markdown as md_to_html
from weasyprint import HTML
import io
from langchain_ollama import OllamaLLM
from mongoengine import FileField


cover_bp = Blueprint("cover", __name__)

@cover_bp.route("/cover_letters", methods=["GET"])
def get_cover_letters():
    """
    Retrieves the list of cover letter filenames for the user
    
    :return list of filenames
    """
    userid = get_userid_from_header()
    try:
        user = Users.objects(id=userid).first()
        if not user.covers:
            return []
        
    except:
        return jsonify({"error": "cover letter could not be found"}), 400
    
    filenames = [
        cover.filename or f"cover_{index}.pdf" for index, cover in enumerate(user.covers)
    ]
    
    return jsonify({"filenames": filenames}), 200

@cover_bp.route("/cover_letters/<int:cover_idx>", methods=["GET"])
def get_cover_letter_file(cover_idx):
    """
    Retrieves a cover letter file by index
    
    :param cover_idx: index of the cover letter
    :return: response with cover letter attached
    """
    userid = get_userid_from_header()
    try:
        user = Users.objects(id=userid).first()
        if not user.covers or cover_idx >= len(user.covers):
            raise FileNotFoundError
        
    except:
        return jsonify({"error": "cover letter could not be foudn"}), 400
    
    cover = user.covers[cover_idx]
    cover.seek(0)
    filename = cover.filename or f"cover_{cover_idx}.pdf"
    
    response = send_file(
        cover,
        mimetype="application/pdf",
        download_name=filename,
        as_attachment=True
    )
    response.headers["x-filename"] = filename
    response.headers["Access-Control-Expose-Headers"] = "x-filename"
    return response, 200

@cover_bp.route("/cover_letters", methods=["POST"])
def upload_cover_letter():
    try:
        userid = get_userid_from_header()
        user = Users.objects(id=userid).first()

        try:
            file = request.files["file"]
        except:
            return jsonify({"error": "No cover letter found in the input"}), 400

        file.seek(0)
        new_file = db.GridFSProxy()
        new_file.put(
            file,
            filename=file.filename,
            content_type="application/pdf"
        )
        user.covers.append(new_file)
        user.save()
        return jsonify({"message": "cover letter successfully added", "filename": new_file.filename}), 200
    
    except Exception as e:
        print("Upload failed:", e)
        return jsonify({"error": "Internal server error"}), 500

@cover_bp.route("/cover_letters/<int:cover_idx>", methods=["DELETE"])
def delete_cover_letter(cover_idx):
    """
    Deletes a cover letter by id
    
    :param cover_idx: index of cover letter to delete
    :return: response
    """
    userid = get_userid_from_header()
    try:
        user = Users.objects(id=userid).first()
        if not user.covers or cover_idx >= len(user.covers):
            raise FileNotFoundError
        
    except:
        return jsonify({"error": "cover letter could not be found"}), 400
    
    del user.covers[cover_idx]
    user.save()
    return jsonify({"success": "successfully deleted cover letter"}), 200

@cover_bp.route("/save_cover_letter", methods=["POST"])
def save_cover_letter():
    """
    Saves a cover letter from the AI generated ones to a user's cover letters.
    This route accepts the cover letter text (in Markdown) generated by the resume route.
    It then wraps the markdown output in a full HTML document, converts it to PDF, 
    and stores the PDF in MongoEngine's GridFS.
    """
    userid = get_userid_from_header()
    try:
        user = Users.objects(id=userid).first()
    except Exception as e:
        current_app.logger.error("User retrieval failed: %s", e)
        return jsonify({"error": "User not found"}), 400

    data = request.json
    cover_letter_text = data.get("cover_letter")
    resume_idx = data.get("resume_idx")  # Used for naming

    if not cover_letter_text:
        return jsonify({"error": "No cover letter provided"}), 400

    # Convert markdown to HTML content:
    # Wrap the converted markdown in a full HTML document structure.
    html_content = f"""
    <html>
      <head>
        <meta charset="utf-8">
        <style>
          /* Add any styling needed for the PDF */
          body {{
            font-family: Arial, sans-serif;
            line-height: 1.4;
            margin: 1cm;
          }}
        </style>
      </head>
      <body>
        {md_to_html(cover_letter_text)}
      </body>
    </html>
    """
    current_app.logger.debug("HTML content generated: %s", html_content)

    # Convert HTML to PDF using WeasyPrint
    pdf_buffer = io.BytesIO()
    try:
        HTML(string=html_content).write_pdf(pdf_buffer)
    except Exception as e:
        current_app.logger.error("WeasyPrint conversion failed: %s", e)
        return jsonify({"error": "Failed to generate PDF"}), 500

    pdf_buffer.seek(0)

    # Save PDF file to covers (GridFS)
    # Use FileField().put() to wrap the BytesIO into a proper GridFSProxy.
    file_field = db.GridFSProxy()
    try:
        file_field.put(
            pdf_buffer,
            filename=f"cover_letter_resume{resume_idx}.pdf",
            content_type="application/pdf"
        )
    except Exception as e:
        current_app.logger.error("FileField.put() failed: %s", e)
        return jsonify({"error": "Failed to store the PDF"}), 500

    user.covers.append(file_field)
    user.save()

    return jsonify({"message": "Cover letter saved successfully as PDF"}), 200